<!DOCTYPE html>
<html lang="en" dir="auto">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>online matching I | deterministic | ariana&#39;s blog</title>
<meta name="keywords" content="">
<meta name="description" content="Professor Tang&rsquo;s online seminar course today covers online matching.
(very short) motivation
The (offline) maximum matching problem is a well-studied area in graph theory, even though some cases (e.g., on general graphs with weights) can be NP-hard. Classic algorithms have provided efficient solutions for specific cases:

Bipartite matching: Solved using the Ford-Fulkerson Algorithm for maximum flow.
Weighted bipartite matching: Uses the Hungarian Algorithm to find an optimal match.
Unweighted general graphs: Solved by Edmonds&rsquo; Blossom Algorithm, which extends matching theory to handle odd-length cycles.

These problems have wide applications, from job assignments to network design. Here&rsquo;s a snapshot of real-world examples:">
<meta name="author" content="">
<link rel="canonical" href="//localhost:1313/posts/online_matching/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.5cfc680b1eeaeef9efbced92d46c2a9e876b72ee14fba85846afc4cff9e6e6f8.css" integrity="sha256-XPxoCx7q7vnvvO2S1Gwqnodrcu4U&#43;6hYRq/Ez/nm5vg=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js" integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG&#43;9vmJ0cTS&#43;ovo0FeA="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="//localhost:1313/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="//localhost:1313/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="//localhost:1313/favicon-32x32.png">
<link rel="apple-touch-icon" href="//localhost:1313/apple-touch-icon.png">
<link rel="mask-icon" href="//localhost:1313/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="//localhost:1313/posts/online_matching/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css" integrity="sha384-GvrOXuhMATgEsSwCs4smul74iXGOixntILdUW9XmUC6+HX0sLNAK3q71HotJqlAn" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.js" integrity="sha384-cpW21h6RZv/phavutF+AuVYrr+dA8xD9zs6FwLpaCct6O9ctzYFfFr4dgmgccOTx" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/contrib/auto-render.min.js" integrity="sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05" crossorigin="anonymous"
    onload="renderMathInElement(document.body);"></script>
<script>
    document.addEventListener("DOMContentLoaded", function() {
        renderMathInElement(document.body, {
          
          
          delimiters: [
              {left: '$$', right: '$$', display: true},
              {left: '$', right: '$', display: false},
              {left: '\\(', right: '\\)', display: false},
              {left: '\\[', right: '\\]', display: true}
          ],
          
          throwOnError : false
        });
    });
</script>




<meta property="og:title" content="online matching I | deterministic" />
<meta property="og:description" content="Professor Tang&rsquo;s online seminar course today covers online matching.
(very short) motivation
The (offline) maximum matching problem is a well-studied area in graph theory, even though some cases (e.g., on general graphs with weights) can be NP-hard. Classic algorithms have provided efficient solutions for specific cases:

Bipartite matching: Solved using the Ford-Fulkerson Algorithm for maximum flow.
Weighted bipartite matching: Uses the Hungarian Algorithm to find an optimal match.
Unweighted general graphs: Solved by Edmonds&rsquo; Blossom Algorithm, which extends matching theory to handle odd-length cycles.

These problems have wide applications, from job assignments to network design. Here&rsquo;s a snapshot of real-world examples:" />
<meta property="og:type" content="article" />
<meta property="og:url" content="//localhost:1313/posts/online_matching/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-11-18T23:06:02+08:00" />
<meta property="article:modified_time" content="2024-11-18T23:06:02+08:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="online matching I | deterministic"/>
<meta name="twitter:description" content="Professor Tang&rsquo;s online seminar course today covers online matching.
(very short) motivation
The (offline) maximum matching problem is a well-studied area in graph theory, even though some cases (e.g., on general graphs with weights) can be NP-hard. Classic algorithms have provided efficient solutions for specific cases:

Bipartite matching: Solved using the Ford-Fulkerson Algorithm for maximum flow.
Weighted bipartite matching: Uses the Hungarian Algorithm to find an optimal match.
Unweighted general graphs: Solved by Edmonds&rsquo; Blossom Algorithm, which extends matching theory to handle odd-length cycles.

These problems have wide applications, from job assignments to network design. Here&rsquo;s a snapshot of real-world examples:"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "//localhost:1313/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "online matching I | deterministic",
      "item": "//localhost:1313/posts/online_matching/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "online matching I | deterministic",
  "name": "online matching I | deterministic",
  "description": "Professor Tang\u0026rsquo;s online seminar course today covers online matching.\n(very short) motivation The (offline) maximum matching problem is a well-studied area in graph theory, even though some cases (e.g., on general graphs with weights) can be NP-hard. Classic algorithms have provided efficient solutions for specific cases:\nBipartite matching: Solved using the Ford-Fulkerson Algorithm for maximum flow. Weighted bipartite matching: Uses the Hungarian Algorithm to find an optimal match. Unweighted general graphs: Solved by Edmonds\u0026rsquo; Blossom Algorithm, which extends matching theory to handle odd-length cycles. These problems have wide applications, from job assignments to network design. Here\u0026rsquo;s a snapshot of real-world examples:\n",
  "keywords": [
    
  ],
  "articleBody": "Professor Tang’s online seminar course today covers online matching.\n(very short) motivation The (offline) maximum matching problem is a well-studied area in graph theory, even though some cases (e.g., on general graphs with weights) can be NP-hard. Classic algorithms have provided efficient solutions for specific cases:\nBipartite matching: Solved using the Ford-Fulkerson Algorithm for maximum flow. Weighted bipartite matching: Uses the Hungarian Algorithm to find an optimal match. Unweighted general graphs: Solved by Edmonds’ Blossom Algorithm, which extends matching theory to handle odd-length cycles. These problems have wide applications, from job assignments to network design. Here’s a snapshot of real-world examples:\nStealing a page from Professor Tang’s slide\nHowever, many of these matching problems occur in online settings…\nwhy online is fascinating Let’s start with the classical online bipartite matching problem:\nStealing another page from Professor Tang’s slide\nOne side of the bipartite graph (e.g., workers) is fixed and known in advance. The other side (e.g., jobs) with edges arrives one-by-one in an online fashion. Upon arrival, a decision must be made immediately and irrevocably: Does this new node connect to one of the available nodes on the fixed side? The objective is to maximize the number of matches. We study the competitive ratio (the worst ratio in any graph and any arrival order) $$ \\inf_{\\text{instances}}\\frac{\\text{ALG}}{\\text{OPT}}. $$\nNotice that it’s prior free.\ndeterministic algorithm Consider the greedy algorithm—matching an online vertex whenever it is possible. The greedy algorithm is 1/2-competitive.\nNotice that greedy algorithm’s matching guarantees that for each edge, at least one of the endpoints is matched. This provides that greedy matching is at least 1/2 approximation of the any matching (hence, maximum matching). A simple 4-point example can upper bound the algorithm’s performance. offline nodes (left) and online nodes (right). the 1/2 instance can be constructed by, if the alg. connects the first online node with one of the offline node, let the second online node be connected only with this occupied offline node.\nSad. But this instance is so stupid that we would expect randomized algorithm to have improvement—we’ll talk about it tmrw, with high probability.\n",
  "wordCount" : "349",
  "inLanguage": "en",
  "datePublished": "2024-11-18T23:06:02+08:00",
  "dateModified": "2024-11-18T23:06:02+08:00",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "//localhost:1313/posts/online_matching/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "ariana's blog",
    "logo": {
      "@type": "ImageObject",
      "url": "//localhost:1313/favicon.ico"
    }
  }
}
</script>
    
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Product+Sans:wght@400;700&display=swap" rel="stylesheet">
    
    <link rel="stylesheet" href="//localhost:1313/css/custom.b017fc6c61ff4eacd2943e3c9726e1a935c706d1ea1a1b7c17773e63b47342d3.css">
    
<script async src="https://www.googletagmanager.com/gtag/js?id=AW-16651897053">
</script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'AW-16651897053');
</script>

<script>
  gtag('event', 'conversion', {
      'send_to': 'AW-16651897053/wjItCK3FisUZEN2Rn4Q-',
      'value': 1.0,
      'currency': 'USD'
  });
</script>


<script async src="https://www.googletagmanager.com/gtag/js?id=AW-16651897053"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'AW-16651897053');
</script>

</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="//localhost:1313/" accesskey="h" title="ariana&#39;s blog (Alt + H)">ariana&#39;s blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
                <ul class="lang-switch"><li>|</li>
                </ul>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="//localhost:1313/search" title="search (Alt &#43; /)" accesskey=/>
                    <span>search</span>
                </a>
            </li>
            <li>
                <a href="//localhost:1313/archives" title="archive">
                    <span>archive</span>
                </a>
            </li>
            <li>
                <a href="//localhost:1313/posts/tags" title="tags">
                    <span>tags</span>
                </a>
            </li>
            <li>
                <a href="//localhost:1313/posts/pinned" title="about me">
                    <span>about me</span>
                </a>
            </li>
            <li>
                <a href="//localhost:1313/procrastination_bulletin" title="pending ideas">
                    <span>pending ideas</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      online matching I | deterministic
    </h1>
    <div class="post-meta">&lt;span title=&#39;2024-11-18 23:06:02 &#43;0800 &#43;0800&#39;&gt;November 18, 2024&lt;/span&gt;

</div>
  </header>
  <div class="post-content"><p><a href="http://zhihaotang.com/">Professor Tang</a>&rsquo;s online seminar course today covers online matching.</p>
<h3 id="very-short-motivation">(very short) motivation<a hidden class="anchor" aria-hidden="true" href="#very-short-motivation">#</a></h3>
<p>The (offline) maximum matching problem is a well-studied area in graph theory, even though some cases (e.g., on general graphs with weights) can be NP-hard. Classic algorithms have provided efficient solutions for specific cases:</p>
<ul>
<li><strong>Bipartite matching</strong>: Solved using the <strong>Ford-Fulkerson Algorithm</strong> for maximum flow.</li>
<li><strong>Weighted bipartite matching</strong>: Uses the <strong>Hungarian Algorithm</strong> to find an optimal match.</li>
<li><strong>Unweighted general graphs</strong>: Solved by Edmonds&rsquo; <strong>Blossom Algorithm</strong>, which extends matching theory to handle odd-length cycles.</li>
</ul>
<p>These problems have wide applications, from <strong>job assignments</strong> to <strong>network design</strong>. Here&rsquo;s a snapshot of real-world examples:</p>
<figure class="align-center ">
    <img loading="lazy" src="/online/online_matching_application.jpeg#center"
         alt="Stealing a page from Professor Tang&rsquo;s slide" width="100%"/> <figcaption>
            <p>Stealing a page from Professor Tang&rsquo;s slide</p>
        </figcaption>
</figure>

<p>However, many of these matching problems occur in <strong>online settings</strong>&hellip;</p>
<h3 id="why-online-is-fascinating">why <em>online</em> is fascinating<a hidden class="anchor" aria-hidden="true" href="#why-online-is-fascinating">#</a></h3>
<p>Let’s start with the <strong>classical online bipartite matching</strong> problem:</p>
<figure class="align-center ">
    <img loading="lazy" src="/online/online_matching_model.jpeg#center"
         alt="Stealing another page from Professor Tang&rsquo;s slide" width="100%"/> <figcaption>
            <p>Stealing another page from Professor Tang&rsquo;s slide</p>
        </figcaption>
</figure>

<ul>
<li>One side of the bipartite graph (e.g., workers) is fixed and known in advance.</li>
<li>The other side (e.g., jobs) with edges arrives one-by-one in an online fashion.</li>
<li>Upon arrival, a decision must be made immediately and irrevocably: Does this new node connect to one of the available nodes on the fixed side?</li>
</ul>
<p>The objective is to maximize the number of matches. We study the competitive ratio (the worst ratio in <em><strong>any graph</strong></em> and <em><strong>any arrival order</strong></em>)
$$
\inf_{\text{instances}}\frac{\text{ALG}}{\text{OPT}}.
$$</p>
<p>Notice that it&rsquo;s prior free.</p>
<h3 id="deterministic-algorithm">deterministic algorithm<a hidden class="anchor" aria-hidden="true" href="#deterministic-algorithm">#</a></h3>
<p>Consider the <strong>greedy algorithm</strong>—matching an online vertex whenever it is possible. The greedy algorithm is 1/2-competitive.</p>
<ul>
<li>Notice that greedy algorithm&rsquo;s matching guarantees that for each edge, at least one of the endpoints is matched. This provides that greedy matching is at least 1/2 approximation of the any matching (hence, maximum matching).</li>
<li>A simple 4-point example can upper bound the algorithm&rsquo;s performance.</li>
</ul>
<figure class="align-center ">
    <img loading="lazy" src="/online/det_alg_instance.jpeg#center"
         alt="offline nodes (left) and online nodes (right). the 1/2 instance can be constructed by, if the alg. connects the first online node with one of the offline node, let the second online node be connected only with this occupied offline node." width="100%"/> <figcaption>
            <p>offline nodes (left) and online nodes (right). the 1/2 instance can be constructed by, if the alg. connects the first online node with one of the offline node, let the second online node be connected only with this occupied offline node.</p>
        </figcaption>
</figure>

<p>Sad. But this instance is so stupid that we would expect randomized algorithm to have improvement—we&rsquo;ll talk about it tmrw, with high probability.</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2025 <a href="//localhost:1313/">ariana&#39;s blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script id="usercentrics-cmp" src="https://web.cmp.usercentrics.eu/ui/loader.js" data-settings-id="_KlbvhaKistzRA" async></script>

</body>

</html>
