<!DOCTYPE html>
<html lang="en" dir="auto">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>mechanism design seminar notes | week 3 | ariana&#39;s blog</title>
<meta name="keywords" content="">
<meta name="description" content="Recap of week 2, and motivation for this week&rsquo;s Part I:
In an economy of $n$ agents and $m$ indivisible items, if all agents&rsquo; value functions are Gross-Substitute, the economy has a Walrasian Equilibrium $(\vec S, \vec p)$. The Walrasian Tatônnement process can find the equilibrium efficiently. The allocation also maximizes social welfare.
But one subtle thing to notice about Walrasian Tatônnement is that it converges to an equilibrium. So here&rsquo;s another way of solving it:">
<meta name="author" content="">
<link rel="canonical" href="//localhost:1313/posts/mechanism_design_seminar_week_3/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.5cfc680b1eeaeef9efbced92d46c2a9e876b72ee14fba85846afc4cff9e6e6f8.css" integrity="sha256-XPxoCx7q7vnvvO2S1Gwqnodrcu4U&#43;6hYRq/Ez/nm5vg=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js" integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG&#43;9vmJ0cTS&#43;ovo0FeA="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="//localhost:1313/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="//localhost:1313/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="//localhost:1313/favicon-32x32.png">
<link rel="apple-touch-icon" href="//localhost:1313/apple-touch-icon.png">
<link rel="mask-icon" href="//localhost:1313/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="//localhost:1313/posts/mechanism_design_seminar_week_3/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css" integrity="sha384-GvrOXuhMATgEsSwCs4smul74iXGOixntILdUW9XmUC6+HX0sLNAK3q71HotJqlAn" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.js" integrity="sha384-cpW21h6RZv/phavutF+AuVYrr+dA8xD9zs6FwLpaCct6O9ctzYFfFr4dgmgccOTx" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/contrib/auto-render.min.js" integrity="sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05" crossorigin="anonymous"
    onload="renderMathInElement(document.body);"></script>
<script>
    document.addEventListener("DOMContentLoaded", function() {
        renderMathInElement(document.body, {
          
          
          delimiters: [
              {left: '$$', right: '$$', display: true},
              {left: '$', right: '$', display: false},
              {left: '\\(', right: '\\)', display: false},
              {left: '\\[', right: '\\]', display: true}
          ],
          
          throwOnError : false
        });
    });
</script>




<meta property="og:title" content="mechanism design seminar notes | week 3" />
<meta property="og:description" content="Recap of week 2, and motivation for this week&rsquo;s Part I:
In an economy of $n$ agents and $m$ indivisible items, if all agents&rsquo; value functions are Gross-Substitute, the economy has a Walrasian Equilibrium $(\vec S, \vec p)$. The Walrasian Tatônnement process can find the equilibrium efficiently. The allocation also maximizes social welfare.
But one subtle thing to notice about Walrasian Tatônnement is that it converges to an equilibrium. So here&rsquo;s another way of solving it:" />
<meta property="og:type" content="article" />
<meta property="og:url" content="//localhost:1313/posts/mechanism_design_seminar_week_3/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-10-10T16:55:46+08:00" />
<meta property="article:modified_time" content="2024-10-10T16:55:46+08:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="mechanism design seminar notes | week 3"/>
<meta name="twitter:description" content="Recap of week 2, and motivation for this week&rsquo;s Part I:
In an economy of $n$ agents and $m$ indivisible items, if all agents&rsquo; value functions are Gross-Substitute, the economy has a Walrasian Equilibrium $(\vec S, \vec p)$. The Walrasian Tatônnement process can find the equilibrium efficiently. The allocation also maximizes social welfare.
But one subtle thing to notice about Walrasian Tatônnement is that it converges to an equilibrium. So here&rsquo;s another way of solving it:"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "//localhost:1313/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "mechanism design seminar notes | week 3",
      "item": "//localhost:1313/posts/mechanism_design_seminar_week_3/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "mechanism design seminar notes | week 3",
  "name": "mechanism design seminar notes | week 3",
  "description": "Recap of week 2, and motivation for this week\u0026rsquo;s Part I: In an economy of $n$ agents and $m$ indivisible items, if all agents\u0026rsquo; value functions are Gross-Substitute, the economy has a Walrasian Equilibrium $(\\vec S, \\vec p)$. The Walrasian Tatônnement process can find the equilibrium efficiently. The allocation also maximizes social welfare.\nBut one subtle thing to notice about Walrasian Tatônnement is that it converges to an equilibrium. So here\u0026rsquo;s another way of solving it:\n",
  "keywords": [
    
  ],
  "articleBody": "Recap of week 2, and motivation for this week’s Part I: In an economy of $n$ agents and $m$ indivisible items, if all agents’ value functions are Gross-Substitute, the economy has a Walrasian Equilibrium $(\\vec S, \\vec p)$. The Walrasian Tatônnement process can find the equilibrium efficiently. The allocation also maximizes social welfare.\nBut one subtle thing to notice about Walrasian Tatônnement is that it converges to an equilibrium. So here’s another way of solving it:\nPart I: configuration LP Interger programming formulation The welfare problem can be casted as the following IP: $$ \\begin{align} W_\\text{IP}:=\\max \u0026 \\sum_{i = 1}^n \\sum_{S\\subseteq [m]}v_i(S)x_{i, S} \\cr \\text{s.t.} \u0026 \\sum_{j\\in S}\\sum_{i}x_{i, S} = 1, \\forall j\\in [n]\\cr \u0026 \\sum_{S} x_{i, S} = 1, \\forall i\\in [m]\\cr \u0026 x_{i, S}\\in \\lbrace0, 1\\rbrace, \\forall i\\in [n], S\\subset [m] \\end{align} $$\nLP relaxation and duality Let $W_\\text{LP}$ be the corresponding linear programming relaxation for the above problem: by taking $x_{i, S}\\in [0, 1]$. It can be observed that (proving using the existence of W. Eq) that when all valuations are GS, $W_\\text{LP} = W_\\text{IP}$.\nTheorem If $(v_1, \\ldots, v_m)$ admit Walrasian Equilibrium, then the configuration LP has integrality gap $1$ (i.e. no gap).\nThe LP has $n2^m$ variables, but only $m + n$ constraints. Usually it’s easier to deal with LP with a lot of constraints but fewer variables. Therefore, take dual of the LP: $$ \\begin{align} \\text{(dual) }W_\\text{LP} = \u0026 \\min\\sum_{i\\in [n]} u_i + \\sum_{j\\in [m]}p_j\\cr \\text{s.t. } \u0026 u_i \\ge v_i(S) - \\sum_{j\\in S}p_j, \u0026 \\forall i\\in [n], S\\subseteq [m] \\cr \u0026 p_j \\ge 0, u_i \\ge 0,\u0026 \\forall i\\in [n], j\\in [m] \u0026 \\end{align} $$\nEllipsoid method The dual has $\\mathcal O(2^m)$ constraints and $m + n$ variables. This dual LP can be efficiently solved by using Ellipsoid method, that, given a separation oracle that does the following job:\n[Separation Oracle, w.r.t. an LP]\nInput: a tentative solution $\\vec x$ Output: either $\\vec x$ is feasible, or a constraint is violeted by $\\vec x$. The very first poly-time algorithm for LP is the ellipsoid method! Basically, if, exists poly-time separation oracle, exists poly-time solution for the LP.\nIf we look at the constraint for the dual, fix any $i$: $$ u_i \\ge v_i(S) - \\sum_{j\\in S}p_j, \\forall S\\subseteq[m] $$ this is essentially trying to find $u_i \\ge \\text{value of }D_i(S, p)$. Therefore, if we have a demand oracle w.r.t. every $i$, the LP can be solved in polynomial time.\nMisc: other oracles: value oracle, demand oracle, general communication oracles.\ndemand oracle The last piece of the puzzle to solved the dual -\u003e relaxed LP -\u003e configuration IP.\nTheorem A valuation $v$ is in GS iff. $\\forall \\vec p\\in \\mathbb R_+^m$, $D(v, \\vec p)$ is given by a greedy process.\nSo we do have a demand oracle for GS valuations, and the LP is poly-time solvable.\nPart II: submodular valuation Now we switch to another dimension of the problem: submodular function maxmization subject to matroid constraints.\ngreedy for one sub-modular value function Consider the problem of finding the maximum allocation for a single agent with subodular valuation $v(\\cdot)$ and a uniform matroid constraint $\\mathcal I = \\lbrace S: |S|\\le k\\rbrace$.\n[Greedy]\nInitialize $S \\leftarrow \\emptyset$.\nWHILE $|S| \u003c k$:\n​\t$j^* = \\arg \\max_j v(j | S)$\n​\t$S \\leftarrow S \\cup \\lbrace j^* \\rbrace$.\nReturn $S$.\nTheorem The greedy obtains $v(S) \\ge (1 - \\frac1e) \\text{OPT}$.\nProof sketch.\nLet $S_1, S_2, \\ldots, S_k$ be the sets that is obtained in the steps of the greedy algorithm.\nTo begin with $$ v(S_1) \\ge \\frac1k \\text{OPT} $$ by the submodular assumption. The above can be reorganized to be in the form of $$ \\text{OPT} - v(S_1) \\le \\left(1 - \\frac1k\\right)\\text{OPT}. $$ For $1 - \\frac1e$, we want a way to stuff an exponential to obtain something like $\\left(1 - \\frac1k\\right)^k$. So, it will be nice to have, something like, for each greedy step $i\\ge1$ $$ \\text{OPT} - S_{i + 1} \\le \\left(1 - \\frac1k\\right)\\left(\\text{OPT} - v(S_i)\\right) $$ which is equivalent to $$ v(S_{i + 1}) - v(S_i) \\ge \\frac1k (\\text{OPT} - v(S_i)). $$ Might as well denote the optimal as $\\text{OPT} = v(S^\\star)$. Observations:\n$v(S^\\star \\cup S_i) \\ge \\text{OPT}$.\n$v(S^\\star | S_i) = v(S^\\star \\cup S_i) - v(S_i) \\ge \\text{OPT} - v(S_i)$.\nAt every greedy step $$ v(S^\\star| S_i) \\le \\underbrace{\\sum_{l_i\\in S^*\\setminus S_i} v(l_i|S_i\\cup\\lbrace l_k:k\u003c i\\rbrace)}_\\text{adding in $l_i\\in S^\\star\\setminus S_i$ one by one} $$\nSo, there exists some $l$ such that $v(l|S_i)\\ge \\frac1k (OPT- v(S_i))$. Aka $$ \\text{(greedy) }v(S_{i + 1}) - v(S_i) \\ge v(l| S_i) \\ge \\frac1k (\\text{OPT} - v(S_i)). $$ And the proof is (almost) complete.\nThat’s all for this week. See you!\n",
  "wordCount" : "770",
  "inLanguage": "en",
  "datePublished": "2024-10-10T16:55:46+08:00",
  "dateModified": "2024-10-10T16:55:46+08:00",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "//localhost:1313/posts/mechanism_design_seminar_week_3/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "ariana's blog",
    "logo": {
      "@type": "ImageObject",
      "url": "//localhost:1313/favicon.ico"
    }
  }
}
</script>
    
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Product+Sans:wght@400;700&display=swap" rel="stylesheet">
    
    <link rel="stylesheet" href="//localhost:1313/css/custom.b017fc6c61ff4eacd2943e3c9726e1a935c706d1ea1a1b7c17773e63b47342d3.css">
    
<script async src="https://www.googletagmanager.com/gtag/js?id=AW-16651897053">
</script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'AW-16651897053');
</script>

<script>
  gtag('event', 'conversion', {
      'send_to': 'AW-16651897053/wjItCK3FisUZEN2Rn4Q-',
      'value': 1.0,
      'currency': 'USD'
  });
</script>


<script async src="https://www.googletagmanager.com/gtag/js?id=AW-16651897053"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'AW-16651897053');
</script>

</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="//localhost:1313/" accesskey="h" title="ariana&#39;s blog (Alt + H)">ariana&#39;s blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
                <ul class="lang-switch"><li>|</li>
                </ul>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="//localhost:1313/search" title="search (Alt &#43; /)" accesskey=/>
                    <span>search</span>
                </a>
            </li>
            <li>
                <a href="//localhost:1313/archives" title="archive">
                    <span>archive</span>
                </a>
            </li>
            <li>
                <a href="//localhost:1313/posts/tags" title="tags">
                    <span>tags</span>
                </a>
            </li>
            <li>
                <a href="//localhost:1313/posts/pinned" title="about me">
                    <span>about me</span>
                </a>
            </li>
            <li>
                <a href="//localhost:1313/procrastination_bulletin" title="pending ideas">
                    <span>pending ideas</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      mechanism design seminar notes | week 3
    </h1>
    <div class="post-meta">&lt;span title=&#39;2024-10-10 16:55:46 &#43;0800 CST&#39;&gt;October 10, 2024&lt;/span&gt;

</div>
  </header>
  <div class="post-content"><h3 id="recap-of-week-2postsmechanism_design_seminar_week_2-and-motivation-for-this-weeks-part-i">Recap of <a href="/posts/mechanism_design_seminar_week_2/">week 2</a>, and motivation for this week&rsquo;s Part I:<a hidden class="anchor" aria-hidden="true" href="#recap-of-week-2postsmechanism_design_seminar_week_2-and-motivation-for-this-weeks-part-i">#</a></h3>
<p>In an economy of $n$ agents and $m$ indivisible items, if all agents&rsquo; value functions are Gross-Substitute, the economy has a Walrasian Equilibrium $(\vec S, \vec p)$. The Walrasian Tatônnement process can find the equilibrium efficiently. The allocation also maximizes social welfare.</p>
<p>But one subtle thing to notice about Walrasian Tatônnement is that <strong>it <em>converges</em> to an equilibrium</strong>. So here&rsquo;s another way of solving it:</p>
<h2 id="part-i-configuration-lp">Part I: configuration LP<a hidden class="anchor" aria-hidden="true" href="#part-i-configuration-lp">#</a></h2>
<h3 id="interger-programming-formulation">Interger programming formulation<a hidden class="anchor" aria-hidden="true" href="#interger-programming-formulation">#</a></h3>
<p>The welfare problem can be casted as the following IP:
$$
\begin{align}
W_\text{IP}:=\max &amp; \sum_{i = 1}^n \sum_{S\subseteq [m]}v_i(S)x_{i, S} \cr
\text{s.t.} &amp; \sum_{j\in S}\sum_{i}x_{i, S} = 1, \forall j\in [n]\cr
&amp; \sum_{S} x_{i, S} = 1, \forall i\in [m]\cr
&amp; x_{i, S}\in \lbrace0, 1\rbrace, \forall i\in [n], S\subset [m]
\end{align}
$$</p>
<h3 id="lp-relaxation-and-duality">LP relaxation and duality<a hidden class="anchor" aria-hidden="true" href="#lp-relaxation-and-duality">#</a></h3>
<p>Let $W_\text{LP}$ be the corresponding linear programming relaxation for the above problem: by taking $x_{i, S}\in [0, 1]$. It can be observed that (proving using the existence of W. Eq) that when all valuations are GS, $W_\text{LP} = W_\text{IP}$.</p>
<p><u><strong>Theorem</strong></u> If $(v_1, \ldots, v_m)$ admit Walrasian Equilibrium, then the configuration LP has integrality gap $1$ (i.e. no gap).</p>
<p>The LP has $n2^m$ variables, but only $m + n$ constraints. Usually it&rsquo;s easier to deal with LP with a lot of constraints but fewer variables. Therefore, take dual of the LP:
$$
\begin{align}
\text{(dual) }W_\text{LP} = &amp;  \min\sum_{i\in [n]} u_i + \sum_{j\in [m]}p_j\cr
\text{s.t. } &amp; u_i \ge v_i(S) - \sum_{j\in S}p_j, &amp; \forall i\in [n], S\subseteq [m] \cr
&amp; p_j \ge 0, u_i \ge 0,&amp; \forall i\in [n], j\in [m] &amp;
\end{align}
$$</p>
<h3 id="ellipsoid-method">Ellipsoid method<a hidden class="anchor" aria-hidden="true" href="#ellipsoid-method">#</a></h3>
<p>The dual has $\mathcal O(2^m)$ constraints and $m + n$ variables. This dual LP can be efficiently solved by using <em><strong>Ellipsoid method</strong></em>, that, given a separation oracle that does the following job:</p>
<blockquote>
<p>[<strong><u>Separation Oracle</u></strong>, w.r.t. an LP]</p>
<ul>
<li>Input: a tentative solution $\vec x$</li>
<li>Output: either $\vec x$ is feasible, or a constraint is violeted by $\vec x$.</li>
</ul>
</blockquote>
<p>The very first poly-time algorithm for LP is the ellipsoid method! Basically, if, exists poly-time separation oracle, exists poly-time solution for the LP.</p>
<p>If we look at the constraint for the dual, fix any $i$:
$$
u_i \ge v_i(S)  - \sum_{j\in S}p_j, \forall S\subseteq[m]
$$
this is essentially trying to find $u_i \ge \text{value of }D_i(S, p)$. Therefore, if we have a <em><strong>demand oracle</strong></em> w.r.t. every $i$, the LP can be solved in polynomial time.</p>
<p>Misc: other oracles: value oracle, demand oracle, general communication oracles.</p>
<h3 id="demand-oracle">demand oracle<a hidden class="anchor" aria-hidden="true" href="#demand-oracle">#</a></h3>
<p>The last piece of the puzzle to solved the dual -&gt; relaxed LP -&gt; configuration IP.</p>
<p><u><strong>Theorem</strong></u> A valuation $v$ is in GS iff. $\forall \vec p\in \mathbb R_+^m$, $D(v, \vec p)$ is given by a <em><strong>greedy</strong></em> process.</p>
<p>So we do have a demand oracle for GS valuations, and the LP is poly-time solvable.</p>
<h2 id="part-ii-submodular-valuation">Part II: submodular valuation<a hidden class="anchor" aria-hidden="true" href="#part-ii-submodular-valuation">#</a></h2>
<p>Now we switch to another dimension of the problem: <em>submodular function maxmization subject to matroid constraints</em>.</p>
<h3 id="greedy-for-one-sub-modular-value-function">greedy for one sub-modular value function<a hidden class="anchor" aria-hidden="true" href="#greedy-for-one-sub-modular-value-function">#</a></h3>
<p>Consider the problem of finding the maximum allocation for a single agent with subodular valuation $v(\cdot)$ and a uniform matroid constraint $\mathcal I = \lbrace S: |S|\le k\rbrace$.</p>
<blockquote>
<p>[<u><strong>Greedy</strong></u>]</p>
<p>Initialize $S \leftarrow \emptyset$.</p>
<p>WHILE $|S| &lt; k$:</p>
<p>​	$j^* = \arg \max_j v(j | S)$</p>
<p>​	$S \leftarrow S \cup \lbrace j^* \rbrace$.</p>
<p>Return $S$.</p>
</blockquote>
<p><u><strong>Theorem</strong></u> The greedy obtains $v(S) \ge (1 - \frac1e) \text{OPT}$.</p>
<blockquote>
<p>Proof sketch.</p>
<p>Let $S_1, S_2, \ldots, S_k$ be the sets that is obtained in the steps of the greedy algorithm.</p>
<p>To begin with
$$
v(S_1) \ge \frac1k \text{OPT}
$$
by the submodular assumption. The above can be reorganized to be in the form of
$$
\text{OPT} - v(S_1) \le \left(1 - \frac1k\right)\text{OPT}.
$$
For $1 - \frac1e$, we want a way to stuff an exponential to obtain something like $\left(1 - \frac1k\right)^k$. So, it will be nice to have, something like, for each greedy step $i\ge1$
$$
\text{OPT} - S_{i + 1} \le \left(1 - \frac1k\right)\left(\text{OPT} - v(S_i)\right)
$$
which is equivalent to
$$
v(S_{i + 1}) - v(S_i) \ge \frac1k (\text{OPT} - v(S_i)).
$$
Might as well denote the optimal as $\text{OPT} = v(S^\star)$. Observations:</p>
<ul>
<li>
<p>$v(S^\star \cup S_i) \ge \text{OPT}$.</p>
</li>
<li>
<p>$v(S^\star | S_i) = v(S^\star \cup S_i) - v(S_i) \ge \text{OPT} - v(S_i)$.</p>
</li>
<li>
<p>At every greedy step
$$
v(S^\star| S_i) \le \underbrace{\sum_{l_i\in S^*\setminus S_i} v(l_i|S_i\cup\lbrace l_k:k&lt; i\rbrace)}_\text{adding in $l_i\in S^\star\setminus S_i$ one by one}
$$</p>
</li>
</ul>
<p>So, there exists some $l$ such that $v(l|S_i)\ge \frac1k (OPT- v(S_i))$. Aka
$$
\text{(greedy) }v(S_{i + 1}) - v(S_i) \ge v(l| S_i) \ge \frac1k (\text{OPT} - v(S_i)).
$$
And the proof is (almost) complete.</p>
</blockquote>
<p>That&rsquo;s all for this week. See you!</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2025 <a href="//localhost:1313/">ariana&#39;s blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script id="usercentrics-cmp" src="https://web.cmp.usercentrics.eu/ui/loader.js" data-settings-id="_KlbvhaKistzRA" async></script>

</body>

</html>
